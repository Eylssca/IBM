<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AI Show Director Demo</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; }

    body {
      background: #050318;
      color: #fff;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    #top-bar {
      padding: 10px 20px;
      font-size: 18px;
      font-weight: 600;
      background: linear-gradient(90deg,#0f172a,#1e293b);
      border-bottom: 1px solid #334155;
    }

    #layout {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 16px;
      padding: 16px;
      flex: 1;
      position: relative;
    }

    /* --- STAGE AREA --- */
    #stage-wrapper {
      position: relative;
      border-radius: 24px;
      overflow: hidden;
      background: radial-gradient(circle at top, #1d2b64, #050318);
      box-shadow: 0 0 40px rgba(0,0,0,0.7);
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* Background container for image or video */
    #background-content {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 1;
    }

    #stage-wrapper * {
        mix-blend-mode: screen;
    }

    #crowd {
      position: absolute;
      inset: 0;
      background-image: radial-gradient(circle, rgba(255,255,255,0.15) 1px, transparent 1px);
      background-size: 8px 8px;
      opacity: 0.2;
      mix-blend-mode: screen;
      z-index: 3;
    }

    #beam-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      mix-blend-mode: screen;
      z-index: 4;
    }

    .beam {
      position: absolute;
      width: 30%;
      height: 120%;
      top: -20%;
      background: radial-gradient(circle at 50% 0%, rgba(255,255,255,0.9), transparent 65%);
      opacity: 0.25;
      transform-origin: top center;
      animation: beamSwing 4s ease-in-out infinite alternate;
      filter: blur(3px);
    }
    .beam.b1 { left: 20%; }
    .beam.b2 { left: 50%; animation-delay: 1s; }
    .beam.b3 { left: 80%; animation-delay: 2s; }

    @keyframes beamSwing {
      0% { transform: rotate(-12deg);}
      100% { transform: rotate(12deg);}
    }

    /* hexagon stage platform */
    #stage-platform {
      position: absolute;
      left: 50%; top: 60%;
      transform: translate(-50%, -50%);
      width: 55%;
      aspect-ratio: 1 / 0.5;
      background: linear-gradient(135deg,#ff8cf0,#ffc857);
      clip-path: polygon(10% 0, 90% 0, 100% 50%, 90% 100%, 10% 100%, 0 50%);
      box-shadow: 0 0 40px rgba(255,120,255,0.8);
      z-index: 5;
    }

    /* AI color filter over everything */
    #ai-filter {
      position: absolute;
      inset: 0;
      mix-blend-mode: screen;
      background: radial-gradient(circle at 50% 20%, rgba(255,0,255,0.4), transparent 70%);
      opacity: 0.0;
      transition: opacity 0.4s ease, background 0.4s ease;
      z-index: 6;
      pointer-events: none;
    }

    /* lyric / chat wall */
    #lyric-wall {
      position: absolute;
      left: 20px;
      top: 20px;
      width: 32%;
      max-height: 60%;
      padding: 12px 18px;
      border-radius: 16px;
      background: linear-gradient(135deg, rgba(15,23,42,0.85), rgba(30,64,175,0.7));
      backdrop-filter: blur(10px);
      font-size: 13px;
      line-height: 1.4;
      overflow: hidden;
      z-index: 7;
    }

    #lyric-title {
      font-weight: 600;
      margin-bottom: 6px;
    }

    #lyric-body {
      opacity: 0.9;
      white-space: pre-wrap;
      font-size: 12px;
    }

    /* left username bubble */
    #user-badge {
      position: absolute;
      left: 4%;
      bottom: 12%;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(15,23,42,0.85);
      backdrop-filter: blur(10px);
      font-size: 13px;
      z-index: 7;
    }

    #user-avatar {
      width: 28px; height: 28px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 20%, #fff, #f973ff);
      display: flex; align-items: center; justify-content: center;
      font-size: 16px;
    }

    /* --- CONTROL PANEL --- */
    #control-panel {
      border-radius: 16px;
      padding: 14px 16px;
      background: linear-gradient(135deg,#020617,#0f172a);
      border: 1px solid #1f2937;
      display: flex;
      flex-direction: column;
      gap: 10px;
      position: relative;
      z-index: 10;
    }

    #control-panel h2 {
      font-size: 16px;
      margin-bottom: 4px;
    }

    .btn-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 6px 14px;
      font-size: 13px;
      cursor: pointer;
      background: linear-gradient(135deg,#4f46e5,#ec4899);
      color: #fff;
      box-shadow: 0 0 12px rgba(79,70,229,0.6);
      transition: transform 0.1s ease, box-shadow 0.1s ease, opacity 0.2s;
    }
    button.secondary {
      background: #111827;
      box-shadow: none;
      border: 1px solid #4b5563;
    }
    button:hover { transform: translateY(-1px); box-shadow: 0 0 16px rgba(236,72,153,0.7);}
    button:active { transform: translateY(0); box-shadow: 0 0 8px rgba(236,72,153,0.5); }

    textarea {
      width: 100%;
      min-height: 70px;
      resize: vertical;
      border-radius: 8px;
      border: 1px solid #4b5563;
      background: #020617;
      color: #e5e7eb;
      padding: 8px;
      font-size: 13px;
    }

    #ai-debug {
      font-size: 11px;
      color: #9ca3af;
      max-height: 90px;
      overflow: auto;
      white-space: pre-wrap;
    }

    #mood-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 10px;
      border-radius: 999px;
      background: rgba(15,23,42,0.9);
      font-size: 11px;
      margin-left: 8px;
    }

    #live-comments {
      max-height: 120px;
      overflow-y: auto;
      background: rgba(15,23,42,0.5);
      border-radius: 8px;
      padding: 8px;
      font-size: 11px;
      line-height: 1.3;
      margin-top: 8px;
    }

    /* Floating incoming comment style */
    .floating-comment {
      position: absolute;
      pointer-events: none;
      z-index: 30;
      padding: 8px 12px;
      border-radius: 12px;
      background: rgba(0,0,0,0.6);
      color: #fff;
      font-size: 13px;
      backdrop-filter: blur(6px);
      transform-origin: center;
      animation: floatPop 5000ms ease forwards;
      filter: drop-shadow(0 6px 18px rgba(0,0,0,0.6));
      white-space: nowrap;
    }

    @keyframes floatPop {
      0% { opacity: 0; transform: translateY(10px) scale(0.9) rotate(-6deg); }
      10% { opacity: 1; transform: translateY(0) scale(1) rotate(0deg); }
      80% { opacity: 1; transform: translateY(-24px) scale(1.02) rotate(4deg); }
      100% { opacity: 0; transform: translateY(-48px) scale(0.98) rotate(2deg); }
    }
  </style>
</head>
<body>
  <div id="top-bar">
    AURA â€” <span style="opacity:0.8;">Live Crowd + AI Demo</span>
  </div>

  <div id="layout">
    <!-- LEFT: STAGE -->
    <div id="stage-wrapper">
      <!-- USE EITHER IMAGE OR VIDEO BELOW BY UNCOMMENTING ONE -->

      <!-- Image background (default) -->
      <img id="background-content" src="1.jpg" alt="Stage Background Image" style="z-index: 1;">

      <!-- Or video background (comment out the img above if using video) -->
      <!--
      <video id="background-content" autoplay muted loop playsinline>
        <source src="your-video.mp4" type="video/mp4" />
        Your browser does not support the video tag.
      </video>
      -->

      <!-- Lighting effects ABOVE background -->
      <div id="beam-layer" style="z-index: 2;">
        <div class="beam b1"></div>
        <div class="beam b2"></div>
        <div class="beam b3"></div>
      </div>

      <!-- AI filter and UI LAST (highest z-index) -->
      <div id="ai-filter" style="z-index: 3;"></div>

      <!-- QR code display -->
      <div style="position: absolute; top: 20px; right: 20px; z-index: 20;">
        <img src="https://api.qrserver.com/v1/create-qr-code/?size=120x120&data=YOUR_SEND_HTML_URL_HERE" 
             alt="Scan to comment" style="border-radius: 12px; box-shadow: 0 4px 20px rgba(255,255,255,0.3);">
        <div style="text-align: center; font-size: 11px; margin-top: 4px; opacity: 0.8;">Scan to react live</div>
      </div>
    </div>

    <!-- RIGHT: CONTROL PANEL -->
    <div id="control-panel">
      <h2>Live Crowd AI <span id="mood-pill">Mood: â€”</span></h2>

      <div style="font-size:12px; opacity:0.85;">
        Crowd comments analyzed in real-time by AI â†“
      </div>

      <!-- Live comment feed -->
      <div id="live-comments">
        No comments yet...
      </div>

      <!-- lyric / chat wall moved to the right control panel -->
      <div id="lyric-wall" style="position:static; width:100%; max-height:160px; margin-top:8px; z-index:9;">
        <div id="lyric-title">Waiting for crowd...</div>
        <div id="lyric-body" style="font-size:12px; opacity:0.9;">Scan QR â†’ Send comments â†’ Watch AI react!</div>
      </div>

      <div id="ai-debug" style="margin-top:8px;"></div>

    </div>
  </div>

  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

  <script>
    const filterEl = document.getElementById('ai-filter');
    const lyricTitleEl = document.getElementById('lyric-title');
    const lyricBodyEl = document.getElementById('lyric-body');
    const debugEl = document.getElementById('ai-debug');
    const moodPill = document.getElementById('mood-pill');
    const liveCommentsEl = document.getElementById('live-comments');

    // Firebase config: REPLACE with your config values
    const firebaseConfig = {
        apiKey: "AIzaSyC34piii16GqYm_It_O4Qm3-5J-j0eJg4w",
        authDomain: "live-show-comments.firebaseapp.com",
        projectId: "live-show-comments",
        storageBucket: "live-show-comments.firebasestorage.app",
        messagingSenderId: "682418279340",
        appId: "1:682418279340:web:e97f0d4c1317eacddc2009",
        databaseURL: "https://live-show-comments-default-rtdb.asia-southeast1.firebasedatabase.app/"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    // Use a root ref to allow removal on load, and a query for last-20 listening
    const commentsRootRef = db.ref("comments");
    const commentsRef = commentsRootRef.limitToLast(20);

    // Clear comment records on every page load (server-side removal).
    // This ensures records are reset each refresh as requested.
    commentsRootRef.remove()
      .then(() => { debugEl.textContent = 'Comment records cleared on page load.'; })
      .catch((e) => { console.warn('Failed to clear comments:', e); });

    // Store recent comments locally
    let recentComments = [];

    // For every incoming message: show floating UI and trigger AI analysis (serialized)
    commentsRef.on("child_added", async (snapshot) => {
      const data = snapshot.val();
      if (!data?.text) return;

      recentComments.push(data.text);
      if (recentComments.length > 10) recentComments.shift();
      updateLiveFeed();
      showFloatingComment(data.text);

      // Immediately analyze each incoming message. We pass only the single new message
      // so the director reacts to the latest audience input. aiRunning/pendingRun
      // ensures calls are serialized when many users send simultaneously.
      analyzeCrowdWithAI([data.text]);
    });

    // Show a floating comment on the stage for a few seconds
    function showFloatingComment(text) {
      const wrapper = document.getElementById('stage-wrapper');
      if (!wrapper) return;
      const el = document.createElement('div');
      el.className = 'floating-comment';
      el.textContent = text;

      // random position within wrapper (avoid edges)
      const w = wrapper.clientWidth;
      const h = wrapper.clientHeight;
      const left = Math.max(8, Math.floor(Math.random() * (w - 160)));
      const top = Math.max(8, Math.floor(Math.random() * (h - 60)));
      el.style.left = `${left}px`;
      el.style.top = `${top}px`;

      // slight random rotation to make it non-directional
      el.style.transform = `rotate(${(Math.random()-0.5)*12}deg)`;

      wrapper.appendChild(el);

      // remove after animation duration + small buffer (5s animation â†’ remove at ~5200ms)
      setTimeout(() => {
        el.remove();
      }, 5200);
    }

    // Restore missing UI helpers
    function updateLiveFeed() {
      liveCommentsEl.innerHTML = recentComments.length
        ? recentComments.map(c => `<div style="margin: 2px 0; opacity: 0.8;">${escapeHtml(c)}</div>`).join('')
        : 'No comments yet...';
      liveCommentsEl.scrollTop = liveCommentsEl.scrollHeight;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Hugging Face Inference API configuration
    // Get your token from https://huggingface.co/settings/tokens (create a READ type token)
    const HF_API_TOKEN = "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"; // Replace with your actual HF token
    // Use a free/fast model for text generation
    const HF_MODEL_ID = "deepseek-ai/DeepSeek-V3.2";

    // After init, make a quick (read-only) check to validate key/model availability
    // and show helpful debug messages.
    async function verifyModel() {
      if (!HF_API_TOKEN || HF_API_TOKEN.includes("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")) {
        debugEl.textContent = 'Hugging Face API token is missing. Set HF_API_TOKEN in the code.';
        return;
      }
      debugEl.textContent = 'Checking Hugging Face model availability...';
      try {
        const resp = await fetch(`https://api-inference.huggingface.co/models/${HF_MODEL_ID}`, {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${HF_API_TOKEN}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            inputs: "test",
            parameters: { max_new_tokens: 5 }
          })
        });
        if (!resp.ok) {
          debugEl.textContent = `Hugging Face model check failed: HTTP ${resp.status}. Check token and model ID.`;
          return;
        }
        debugEl.textContent = `Hugging Face model "${HF_MODEL_ID}" is ready. Real AI calls will be attempted on incoming messages.`;
      } catch (e) {
        debugEl.textContent = `Model verification error: ${e.message}`;
      }
    }

    // call verification once (non-blocking)
    verifyModel();

    // AI call locking to avoid concurrent requests when many users send at the same time
    let aiRunning = false;
    let pendingRun = false;
    let pendingComments = null;

    // Call AI to analyze recent comments and get stage plan
    async function analyzeCrowdWithAI(comments) {
      // If an AI request is already running, queue the latest comments and return.
      if (aiRunning) {
        pendingRun = true;
        pendingComments = comments;
        debugEl.textContent = "ðŸ¤– AI busy â€” queued latest comments.";
        return;
      }
      aiRunning = true;
      debugEl.textContent = "ðŸ¤– AI analyzing crowd...";
      try {
        // Prompt for Hugging Face model: request JSON output with specific keys
        const prompt = `You are an AI show director. Analyze these live crowd comments and output ONLY valid JSON (no markdown, no code fences):
 {
   "effect": "LASER_BURST|ENCORE_GOLD|STROBE_RED|STROBE_BLUE|PULSE_NEON|FIREWORKS|SPARKLE|CHILL_WAVE|COZY_MODE|RAINBOW_FLOW",
   "primaryColor": "#rrggbb",
   "intensity": 0.1-1.0,
   "mcLine": "short hype MC line (20 words max)",
   "explanation": "why this choice (30 words max)"
 }
 Comments:
 - ${comments.join('\n- ')}

 Choose an effect and intensity according to crowd energy; intensity should reflect how strong the lighting should be (0.1 = very light, 1.0 = maximum). Output ONLY the JSON object.`;

        // Send prompt to Hugging Face directly
        const response = await fetch(`https://api-inference.huggingface.co/models/${HF_MODEL_ID}`, {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${HF_API_TOKEN}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            inputs: prompt,
            parameters: { max_new_tokens: 250, temperature: 0.3 }
          })
        });

         if (!response.ok) {
           const errText = await response.text().catch(()=>'<no-body>');
           debugEl.textContent = `Hugging Face HTTP ${response.status}: ${errText}`;
           aiRunning = false;
           if (pendingRun) { pendingRun=false; analyzeCrowdWithAI(pendingComments); pendingComments=null; }
           return;
         }

        const data = await response.json().catch(e => { debugEl.textContent = `AI proxy response parse error: ${e.message}`; return null; });
         if (!data) {
           aiRunning = false;
           if (pendingRun) { pendingRun=false; analyzeCrowdWithAI(pendingComments); pendingComments=null; }
           return;
         }

        // Extract generated text from Hugging Face response (array with generated_text field)
        const rawText = (Array.isArray(data) && data[0]?.generated_text) ? data[0].generated_text
                        : data?.generated_text || data?.text || data?.output?.[0]?.text || null;

         if (!rawText) {
           debugEl.textContent = 'Hugging Face response missing generated_text field.';
           aiRunning = false;
           if (pendingRun) { pendingRun=false; analyzeCrowdWithAI(pendingComments); pendingComments=null; }
           return;
         }

         const cleaned = extractJSONFromText(typeof rawText === 'object' ? JSON.stringify(rawText) : String(rawText));
          if (!cleaned) {
           debugEl.textContent = 'Hugging Face response did not contain valid JSON.';
           aiRunning = false;
           if (pendingRun) { pendingRun=false; analyzeCrowdWithAI(pendingComments); pendingComments=null; }
           return;
         }

          let plan;
          try {
            plan = JSON.parse(cleaned);
          } catch (e) {
            debugEl.textContent = `JSON parse error: ${e.message}`;
            aiRunning = false;
            if (pendingRun) { pendingRun=false; analyzeCrowdWithAI(pendingComments); pendingComments=null; }
            return;
          }
          applyStagePlan(plan);
          debugEl.textContent = `AI Plan: ${plan.effect} (${Math.round((plan.intensity ?? 0.5)*100)}%)`;
       } catch (e) {
         debugEl.textContent = `Hugging Face error: ${e.message}`;
         moodPill.textContent = 'Mood: â€”';
       } finally {
         aiRunning = false;
         if (pendingRun) {
           pendingRun = false;
           const toRun = pendingComments || comments;
           pendingComments = null;
           // fire next run (don't await here to avoid blocking)
           analyzeCrowdWithAI(toRun);
         }
       }
     }

    // Extract JSON substring from text (handles ```json ``` fences and backticks)
    function extractJSONFromText(text) {
      // try to find the first "{" and last "}" that make valid JSON
      const first = text.indexOf('{');
      const last = text.lastIndexOf('}');
      if (first === -1 || last === -1 || last <= first) return null;
      const candidate = text.slice(first, last + 1);
      return candidate;
    }

    // Manual/local AI helpers removed â€” real AI only.

    function applyStagePlan(plan) {
      // Map incoming intensity (0.1-1.0) to percent and category (1..10)
      const inIntensity = Math.max(0.0, Math.min(1.0, plan.intensity ?? 0.5));
      const percent = Math.round(inIntensity * 100);
      const category = percent === 0 ? 0 : Math.min(9, Math.ceil(percent / 10) - 1);
      const strength = (category + 1) / 10; // 0.1 .. 1.0

      // 10-category â†’ effect mapping (light â†’ strong) with base (pale) and vivid colors + mood label
      const EFFECT_MAP = [
        { effect: 'SPARKLE',      baseColor: '#e6f7ff', vividColor: '#7fd3ff',  mood: 'âœ¨ Calm'    }, // 1
        { effect: 'CHILL_WAVE',   baseColor: '#eafcff', vividColor: '#4fd1e0',  mood: 'ðŸŒŠ Chill'   }, // 2
        { effect: 'COZY_MODE',    baseColor: '#eef6ff', vividColor: '#60a5fa',  mood: 'ðŸŒ™ Cozy'    }, // 3
        { effect: 'PULSE_NEON',   baseColor: '#f0fff4', vividColor: '#34d399',  mood: 'ðŸ’¡ Pulse'   }, // 4
        { effect: 'STROBE_BLUE',  baseColor: '#f2f8ff', vividColor: '#3b82f6',  mood: 'ðŸ”µ Strobe'  }, // 5
        { effect: 'STROBE_RED',   baseColor: '#fff3f3', vividColor: '#ef4444',  mood: 'ðŸ”´ Strobe'  }, // 6
        { effect: 'LASER_BURST',  baseColor: '#fff0fb', vividColor: '#ff6ec7',  mood: 'âš¡ Laser'    }, // 7
        { effect: 'FIREWORKS',    baseColor: '#fff8f0', vividColor: '#ffb020',  mood: 'ðŸŽ† Fireworks'}, // 8
        { effect: 'ENCORE_GOLD',  baseColor: '#fff9f2', vividColor: '#ffc857',  mood: 'âœ¨ Encore'   }, // 9
        { effect: 'RAINBOW_FLOW', baseColor: '#fff6fb', vividColor: '#ff4da6',  mood: 'ðŸŒˆ Riot'     }  // 10
      ];

      const chosen = EFFECT_MAP[category];

      // Mix a pale base color and a vivid color according to strength so low categories look pale/calm and high are vivid/sharp
      function mixHexColors(a, b, t) {
        const pa = a.replace('#','');
        const pb = b.replace('#','');
        const ar = parseInt(pa.substring(0,2),16), ag = parseInt(pa.substring(2,4),16), ab = parseInt(pa.substring(4,6),16);
        const br = parseInt(pb.substring(0,2),16), bg = parseInt(pb.substring(2,4),16), bb = parseInt(pb.substring(4,6),16);
        const rr = Math.round(ar + (br - ar) * t);
        const rg = Math.round(ag + (bg - ag) * t);
        const rb = Math.round(ab + (bb - ab) * t);
        return `#${rr.toString(16).padStart(2,'0')}${rg.toString(16).padStart(2,'0')}${rb.toString(16).padStart(2,'0')}`;
      }

      const primaryHex = plan.primaryColor || mixHexColors(chosen.baseColor, chosen.vividColor, strength);
      const vividHex = mixHexColors(chosen.baseColor, chosen.vividColor, Math.min(1, strength + 0.25));

      // Visual strength depends on category (increasing): change opacity, saturation, blur â†’ sharpness
      filterEl.style.background = `radial-gradient(circle at 50% 20%, ${hexWithAlpha(primaryHex, 0.25 + strength*0.6)}, transparent 70%)`;
      filterEl.style.opacity = 0.08 + strength * 0.9; // subtle -> bold

      // Beams become more opaque, more saturated, and sharper as strength increases
      document.querySelectorAll('.beam').forEach((b, i) => {
        const beamOpacity = (0.03 + strength * 0.85);
        b.style.opacity = beamOpacity.toString();
        // blur reduces with strength to make beams sharper at high intensity
        const blurPx = Math.max(0.5, 4 - (strength * 3.5));
        b.style.filter = `blur(${blurPx}px)`;
        b.style.background = `radial-gradient(circle at 50% 0%, ${hexWithAlpha(vividHex, 0.95)}, transparent 65%)`;
      });

      // Platform glow stronger and more vivid with strength
      const stagePlatform = document.getElementById('stage-platform');
      if (stagePlatform) {
        const glowSize = 8 + (strength * 120);
        stagePlatform.style.boxShadow = `0 0 ${glowSize}px ${hexWithAlpha(vividHex, 0.9 * strength)}`;
      }

      // Update lyric / UI; show the category-mapped effect and mood
      lyricTitleEl.textContent = plan.mcLine || 'AI MC reacting to the crowd...';
      lyricBodyEl.textContent =
        `Effect: ${chosen.effect}\nIntensity: ${percent}% (category ${category + 1}/10)\n\n${plan.explanation || ''}`;

      const moodLabel = chosen.mood || 'ðŸŽ¨ Scene';
      moodPill.textContent = 'Mood: ' + moodLabel;
      debugEl.textContent += `\n\n[Displayed plan: ${percent}% â†’ category ${category + 1} â†’ ${chosen.effect} / ${moodLabel}]`;
    }

    function hexWithAlpha(hex, alpha) {
      const c = hex.replace('#', '');
      const r = parseInt(c.substring(0, 2), 16);
      const g = parseInt(c.substring(2, 4), 16);
      const b = parseInt(c.substring(4, 6), 16);
      return `rgba(${r},${g},${b},${alpha})`;
    }
  </script>
</body>
</html>
